function deepEqual(a, b) {
  //Объявление счетчиков
  var propsInA = 0, propsInB = 0;

  //Точное сравнение по типу и содержимому (подходит для простых переменных)
  if (a === b) {
    return true;
  }

  //Если a || b не объект или хотя бы один null => они не равны
  if (a === null || typeof a !== "object" ||
      b === null || typeof b !== "object")
    return false;

  //Считаем количество свойств в объекте а
  for (var i in a) {
    propsInA += 1;
  }

  //Считаем количество свойств в объекте b
  //if проверяет - существует ли свойство prop из объекта b в объекте a
  //если существует, то результат  выражения prop in a будет true, но
  //у нас отрицание выражения - значит будет false (нам же не нужно проваливаться в if)
  // раз левая часть выражения || false - мы идем считать правую сторону, и если она будет false
  //то мы не вернем false и продолжит работать цикл for(var prop in b), пока не кончатся свойства
  //в объекте b. Затем, если мы не вернули false,
  //мы срвниванием счетчики (количетсво) свойств в a и в b.
  //Так вот, правая часть выражения ||. !deepEqual(a[prop], b[prop]) - самое интересное.
  //Мы запускаем еще раз саму же процедуру изнутри себя, но с другими параметрами.
  //Такой подход называется РЕКУРСИЯ.
  //Допустим, у нас на вход подавались два объекта:
  //var a = {one: 1}, b = {one: 1}
  //Таким образом мы вызывем выражение !deepEqual(a["one"], b["one"])
  //Доступ к значениям в объекте можно получать как с массивами, только индексов нет, есть ключи.
  //Но, обращаться можно только если ключ прдеставлен как строка, поэтому one в кавычках.
  //p.s.: когда мы перебираем (prop on b) - в prop у нас хранится строка, поэтому
  //обращение a[prop] корректно работает.
  //Надеюсь, не запутал.
  for (var prop in b) {
    propsInB += 1;
    if (!(prop in a) || !deepEqual(a[prop], b[prop]))
      return false;
  }

  return propsInA == propsInB;
}